// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Api from "../../config/Api.res.js";
import * as Fetch from "../../bindings/Fetch.res.js";
import * as React from "react";
import * as Materialize from "../../bindings/Materialize.res.js";
import * as Stdlib_JSON from "@rescript/runtime/lib/es6/Stdlib_JSON.js";
import * as LocalStorage from "../../bindings/LocalStorage.res.js";
import * as Stdlib_JsExn from "@rescript/runtime/lib/es6/Stdlib_JsExn.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function validatePassword(password, passwordConfirm) {
  if (password === "" && passwordConfirm === "") {
    return "Empty";
  } else if (password !== passwordConfirm) {
    return {
      TAG: "Invalid",
      _0: "Passwords don't match"
    };
  } else if (password.length <= 6) {
    return {
      TAG: "Invalid",
      _0: "Passwords should be > 6 characters"
    };
  } else {
    return "Valid";
  }
}

function reducer(state, action) {
  if (typeof action !== "object") {
    switch (action) {
      case "ToggleEdit" :
        return {
          viewMode: state.viewMode === "ProfileView" ? "EditView" : "ProfileView",
          user: state.user,
          email: state.email,
          firstName: state.firstName,
          lastName: state.lastName,
          password: "",
          passwordConfirm: "",
          isSubmitting: state.isSubmitting,
          updateError: undefined
        };
      case "Submit" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: state.email,
          firstName: state.firstName,
          lastName: state.lastName,
          password: state.password,
          passwordConfirm: state.passwordConfirm,
          isSubmitting: true,
          updateError: state.updateError
        };
      case "CancelEdit" :
        return {
          viewMode: "ProfileView",
          user: state.user,
          email: state.user.email,
          firstName: state.user.firstName,
          lastName: state.user.lastName,
          password: "",
          passwordConfirm: "",
          isSubmitting: state.isSubmitting,
          updateError: undefined
        };
    }
  } else {
    switch (action.TAG) {
      case "UpdateEmail" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: action._0,
          firstName: state.firstName,
          lastName: state.lastName,
          password: state.password,
          passwordConfirm: state.passwordConfirm,
          isSubmitting: state.isSubmitting,
          updateError: state.updateError
        };
      case "UpdateFirstName" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: state.email,
          firstName: action._0,
          lastName: state.lastName,
          password: state.password,
          passwordConfirm: state.passwordConfirm,
          isSubmitting: state.isSubmitting,
          updateError: state.updateError
        };
      case "UpdateLastName" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: state.email,
          firstName: state.firstName,
          lastName: action._0,
          password: state.password,
          passwordConfirm: state.passwordConfirm,
          isSubmitting: state.isSubmitting,
          updateError: state.updateError
        };
      case "UpdatePassword" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: state.email,
          firstName: state.firstName,
          lastName: state.lastName,
          password: action._0,
          passwordConfirm: state.passwordConfirm,
          isSubmitting: state.isSubmitting,
          updateError: state.updateError
        };
      case "UpdatePasswordConfirm" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: state.email,
          firstName: state.firstName,
          lastName: state.lastName,
          password: state.password,
          passwordConfirm: action._0,
          isSubmitting: state.isSubmitting,
          updateError: state.updateError
        };
      case "SubmitSuccess" :
        let user = action._0;
        return {
          viewMode: "ProfileView",
          user: user,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          password: "",
          passwordConfirm: "",
          isSubmitting: false,
          updateError: undefined
        };
      case "SubmitError" :
        return {
          viewMode: state.viewMode,
          user: state.user,
          email: state.email,
          firstName: state.firstName,
          lastName: state.lastName,
          password: state.password,
          passwordConfirm: state.passwordConfirm,
          isSubmitting: false,
          updateError: action._0
        };
    }
  }
}

function decodeProfileUser(json) {
  let obj = Stdlib_JSON.Decode.object(json);
  if (obj === undefined) {
    return {
      TAG: "Error",
      _0: "Invalid user object"
    };
  }
  let id = obj["_id"];
  let email = obj["email"];
  let name = obj["name"];
  let role = obj["role"];
  if (id === undefined) {
    return {
      TAG: "Error",
      _0: "Missing required user fields"
    };
  }
  if (email === undefined) {
    return {
      TAG: "Error",
      _0: "Missing required user fields"
    };
  }
  if (name === undefined) {
    return {
      TAG: "Error",
      _0: "Missing required user fields"
    };
  }
  let match = Stdlib_JSON.Decode.string(id);
  let match$1 = Stdlib_JSON.Decode.string(email);
  let match$2 = Stdlib_JSON.Decode.object(name);
  if (match === undefined) {
    return {
      TAG: "Error",
      _0: "Invalid user field types"
    };
  }
  if (match$1 === undefined) {
    return {
      TAG: "Error",
      _0: "Invalid user field types"
    };
  }
  if (match$2 === undefined) {
    return {
      TAG: "Error",
      _0: "Invalid user field types"
    };
  }
  let firstJson = match$2["first"];
  let firstName = firstJson !== undefined ? Stdlib_JSON.Decode.string(firstJson) : undefined;
  let lastJson = match$2["last"];
  let lastName = lastJson !== undefined ? Stdlib_JSON.Decode.string(lastJson) : undefined;
  if (firstName === undefined) {
    return {
      TAG: "Error",
      _0: "Missing name fields"
    };
  }
  if (lastName === undefined) {
    return {
      TAG: "Error",
      _0: "Missing name fields"
    };
  }
  let roleTitle;
  if (role !== undefined) {
    let roleObj = Stdlib_JSON.Decode.object(role);
    if (roleObj !== undefined) {
      let titleJson = roleObj["title"];
      roleTitle = titleJson !== undefined ? Stdlib_JSON.Decode.string(titleJson) : undefined;
    } else {
      roleTitle = undefined;
    }
  } else {
    roleTitle = undefined;
  }
  return {
    TAG: "Ok",
    _0: {
      id: match,
      email: match$1,
      firstName: firstName,
      lastName: lastName,
      role: roleTitle
    }
  };
}

let decodeUserUpdateResponse = decodeProfileUser;

async function updateUserProfile(userId, token, email, firstName, lastName, password) {
  let url = Api.baseUrl + `/api/users/` + userId;
  let body = {};
  body["email"] = email;
  body["firstname"] = firstName;
  body["lastname"] = lastName;
  if (password !== undefined) {
    body["password"] = password;
  }
  try {
    let response = await Fetch.put(url, body, token);
    if (response.ok) {
      return decodeProfileUser(await response.json());
    }
    let status = response.status;
    return {
      TAG: "Error",
      _0: `Update failed with status ` + String(status)
    };
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === "JsExn") {
      let msg = Stdlib_JsExn.message(e._1);
      if (msg !== undefined) {
        return {
          TAG: "Error",
          _0: msg
        };
      } else {
        return {
          TAG: "Error",
          _0: "Unknown error occurred"
        };
      }
    }
    throw e;
  }
}

function saveUserInfo(user) {
  let dict = {};
  dict["_id"] = user.id;
  dict["email"] = user.email;
  let nameDict = {};
  nameDict["first"] = user.firstName;
  nameDict["last"] = user.lastName;
  dict["name"] = nameDict;
  let roleTitle = user.role;
  if (roleTitle !== undefined) {
    let roleDict = {};
    roleDict["title"] = roleTitle;
    dict["role"] = roleDict;
  } else {
    dict["role"] = null;
  }
  localStorage.setItem("userInfo", JSON.stringify(dict));
}

function Profile(props) {
  let initialUser = React.useMemo(() => {
    let userInfoStr = LocalStorage.getItemOption("userInfo");
    if (userInfoStr === undefined) {
      return;
    }
    try {
      let json = JSON.parse(userInfoStr);
      let user = decodeProfileUser(json);
      if (user.TAG === "Ok") {
        return user._0;
      } else {
        return;
      }
    } catch (exn) {
      return;
    }
  }, []);
  let token = React.useMemo(() => LocalStorage.getItemOption("user"), []);
  let match = initialUser !== undefined ? [
      true,
      initialUser
    ] : [
      false,
      {
        id: "",
        email: "",
        firstName: "",
        lastName: "",
        role: undefined
      }
    ];
  let user = match[1];
  let initialState_email = user.email;
  let initialState_firstName = user.firstName;
  let initialState_lastName = user.lastName;
  let initialState = {
    viewMode: "ProfileView",
    user: user,
    email: initialState_email,
    firstName: initialState_firstName,
    lastName: initialState_lastName,
    password: "",
    passwordConfirm: "",
    isSubmitting: false,
    updateError: undefined
  };
  let match$1 = React.useReducer(reducer, initialState);
  let dispatch = match$1[1];
  let state = match$1[0];
  let handleSubmit = evt => {
    evt.preventDefault();
    let message = validatePassword(state.password, state.passwordConfirm);
    if (typeof message === "object") {
      return Materialize.showError(message._0);
    }
    if (message === "Empty") {
      dispatch("Submit");
      if (token !== undefined) {
        let updatePromise = async () => {
          let result = await updateUserProfile(state.user.id, token, state.email, state.firstName, state.lastName, undefined);
          if (result.TAG === "Ok") {
            let updatedUser = result._0;
            saveUserInfo(updatedUser);
            dispatch({
              TAG: "SubmitSuccess",
              _0: updatedUser
            });
            return Materialize.showSuccess("Profile Info Updated!");
          }
          let error = result._0;
          dispatch({
            TAG: "SubmitError",
            _0: error
          });
          return Materialize.showError(error);
        };
        updatePromise();
        return;
      }
      dispatch({
        TAG: "SubmitError",
        _0: "No authentication token found"
      });
      return Materialize.showError("No authentication token found");
    }
    dispatch("Submit");
    if (token !== undefined) {
      let updatePromise$1 = async () => {
        let result = await updateUserProfile(state.user.id, token, state.email, state.firstName, state.lastName, state.password);
        if (result.TAG === "Ok") {
          let updatedUser = result._0;
          saveUserInfo(updatedUser);
          dispatch({
            TAG: "SubmitSuccess",
            _0: updatedUser
          });
          return Materialize.showSuccess("Profile Info Updated!");
        }
        let error = result._0;
        dispatch({
          TAG: "SubmitError",
          _0: error
        });
        return Materialize.showError(error);
      };
      updatePromise$1();
      return;
    }
    dispatch({
      TAG: "SubmitError",
      _0: "No authentication token found"
    });
    Materialize.showError("No authentication token found");
  };
  let renderProfileView = () => {
    let roleTitle = state.user.role;
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("div", {
          children: JsxRuntime.jsx("h2", {
            children: "My Profile",
            className: "header center-align"
          }),
          className: "row"
        }),
        JsxRuntime.jsx("div", {
          children: JsxRuntime.jsx("div", {
            children: JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsxs("div", {
                  children: [
                    JsxRuntime.jsx("img", {
                      className: "activator",
                      alt: "Profile logo",
                      src: "mountain.jpg"
                    }),
                    JsxRuntime.jsx("span", {
                      children: state.firstName + " " + state.lastName,
                      className: "card-title activator"
                    })
                  ],
                  className: "card-image waves-effect waves-block waves-light"
                }),
                JsxRuntime.jsxs("div", {
                  children: [
                    JsxRuntime.jsx("a", {
                      children: JsxRuntime.jsx("i", {
                        children: "edit",
                        className: "material-icons cyan lighten-1"
                      }),
                      className: "btn-floating",
                      onClick: param => dispatch("ToggleEdit")
                    }),
                    JsxRuntime.jsx("span", {
                      children: JsxRuntime.jsx("i", {
                        children: "more_vert",
                        className: "material-icons right icon-align"
                      }),
                      className: "card-title activator grey-text text-darken-4"
                    })
                  ],
                  className: "card-action"
                }),
                JsxRuntime.jsxs("div", {
                  children: [
                    JsxRuntime.jsxs("span", {
                      children: [
                        "Full Profile",
                        JsxRuntime.jsx("i", {
                          children: "close",
                          className: "material-icons right"
                        })
                      ],
                      className: "card-title grey-text text-darken-4 center"
                    }),
                    JsxRuntime.jsxs("p", {
                      children: [
                        JsxRuntime.jsx("i", {
                          children: "face",
                          className: "material-icons left icon-align"
                        }),
                        "Name: " + state.firstName + " " + state.lastName
                      ],
                      className: "flow-text"
                    }),
                    JsxRuntime.jsxs("p", {
                      children: [
                        JsxRuntime.jsx("i", {
                          children: "email",
                          className: "material-icons left icon-align"
                        }),
                        "Email: " + state.email
                      ],
                      className: "flow-text"
                    }),
                    roleTitle !== undefined ? JsxRuntime.jsxs("p", {
                        children: [
                          JsxRuntime.jsx("i", {
                            children: "settings",
                            className: "material-icons left icon-align"
                          }),
                          "Role: " + roleTitle
                        ],
                        className: "flow-text"
                      }) : null
                  ],
                  className: "card-reveal"
                })
              ],
              className: "card"
            }),
            className: "col s8 offset-s2"
          }),
          className: "row"
        })
      ]
    });
  };
  let renderEditForm = () => JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: JsxRuntime.jsx("h2", {
          children: "Edit Profile",
          className: "header center-align"
        }),
        className: "row"
      }),
      JsxRuntime.jsxs("form", {
        children: [
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("label", {
                  children: "Email",
                  htmlFor: "email"
                }),
                JsxRuntime.jsx("input", {
                  id: "email",
                  name: "email",
                  type: "text",
                  value: state.email,
                  onChange: evt => {
                    let value = evt.target.value;
                    dispatch({
                      TAG: "UpdateEmail",
                      _0: value
                    });
                  }
                })
              ],
              className: "col s4 offset-s4"
            }),
            className: "row"
          }),
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("label", {
                  children: "First Name",
                  htmlFor: "firstname"
                }),
                JsxRuntime.jsx("input", {
                  id: "firstname",
                  name: "firstname",
                  type: "text",
                  value: state.firstName,
                  onChange: evt => {
                    let value = evt.target.value;
                    dispatch({
                      TAG: "UpdateFirstName",
                      _0: value
                    });
                  }
                })
              ],
              className: "col s4 offset-s4"
            }),
            className: "row"
          }),
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("label", {
                  children: "Last Name",
                  htmlFor: "lastname"
                }),
                JsxRuntime.jsx("input", {
                  id: "lastname",
                  name: "lastname",
                  type: "text",
                  value: state.lastName,
                  onChange: evt => {
                    let value = evt.target.value;
                    dispatch({
                      TAG: "UpdateLastName",
                      _0: value
                    });
                  }
                })
              ],
              className: "col s4 offset-s4"
            }),
            className: "row"
          }),
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("label", {
                  children: "New Password",
                  htmlFor: "password"
                }),
                JsxRuntime.jsx("input", {
                  id: "password",
                  name: "password",
                  type: "password",
                  value: state.password,
                  onChange: evt => {
                    let value = evt.target.value;
                    dispatch({
                      TAG: "UpdatePassword",
                      _0: value
                    });
                  }
                })
              ],
              className: "col s4 offset-s4"
            }),
            className: "row"
          }),
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("label", {
                  children: "Confirm Password",
                  htmlFor: "confirm-password"
                }),
                JsxRuntime.jsx("input", {
                  id: "confirm-password",
                  name: "confirm-password",
                  type: "password",
                  value: state.passwordConfirm,
                  onChange: evt => {
                    let value = evt.target.value;
                    dispatch({
                      TAG: "UpdatePasswordConfirm",
                      _0: value
                    });
                  }
                })
              ],
              className: "col s4 offset-s4"
            }),
            className: "row"
          }),
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("div", {
                children: JsxRuntime.jsx("button", {
                  children: "cancel",
                  className: "btn waves-effect red accent-2 center",
                  onClick: evt => {
                    evt.preventDefault();
                    dispatch("CancelEdit");
                  }
                }),
                className: "col s2 offset-s4"
              }),
              JsxRuntime.jsx("div", {
                children: JsxRuntime.jsx("button", {
                  children: "update",
                  className: "btn waves-effect blue center",
                  disabled: state.isSubmitting,
                  type: "submit"
                }),
                className: "col s2"
              })
            ],
            className: "row"
          })
        ],
        className: "col s10 offset-s1",
        onSubmit: handleSubmit
      })
    ],
    className: "card-panel"
  });
  if (!match[0]) {
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("div", {
          children: JsxRuntime.jsx("div", {
            className: "indeterminate"
          }),
          className: "progress"
        }),
        JsxRuntime.jsx("p", {
          children: "Loading profile...",
          className: "center-align"
        })
      ],
      className: "container"
    });
  }
  let match$2 = state.viewMode;
  let tmp;
  tmp = match$2 === "ProfileView" ? renderProfileView() : renderEditForm();
  return JsxRuntime.jsx("div", {
    children: tmp,
    className: "container"
  });
}

let make = Profile;

let $$default = Profile;

export {
  validatePassword,
  reducer,
  decodeProfileUser,
  decodeUserUpdateResponse,
  updateUserProfile,
  saveUserInfo,
  make,
  $$default as default,
}
/* Api Not a pure module */
